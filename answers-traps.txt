1.查询RISC-V手册可知，寄存器a0-a7保存了函数参数。阅读call.asm代码可知，寄存器a2存储了主函数调用printf函数的一个参数13。
2.实际上，由问题1中的图可以发现，main函数中直接将对函数f、g的调用进行内联优化了，因此printf函数的另一个参数直接为f(8)+1的计算结果12。
3.printf函数的地址为0x628。
4.根据RISC-V手册可知，ra寄存器用于存储返回地址，则该jalr指令执行后会将返回地址存放于ra寄存器中。因此，由下图可知该jalr指令执行后，ra寄存器中的值为0x38。
5.输出为：HE110 World。若RISC-V为大端模式，则i应该设置为0x726c6400才能得到相同输出。而常量57616不论是大端模式还是小端模式都可以被正确识别并转换进制，不需要被换成其他数值。
6.出现这种情况的原因在于，printf函数的函数参数按照顺序依次存放在a1、a2、a3...等寄存器中，而这段代码只提供了一个参数，存放于a1寄存器中，因此执行printf函数打印时，第二个参数会直接使用先前存放在a2寄存器中的值，而这个值取决于此前向a2寄存器赋的值，从而在不同情况下，“y=”后打印出的结果不一定相同。
注：图片及具体回答见实验报告，这里用于通过测试